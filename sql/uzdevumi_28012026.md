GROUP BY — teorija + piemēri + uzdevumi

0) Ko nozīmē GROUP BY?

GROUP BY apvieno rindas “grupās” pēc izvēlētā lauka(-iem) un ļauj katrai grupai aprēķināt agregātu (piem., COUNT, SUM, AVG, MIN, MAX).
	•	Pirms GROUP BY ir daudz rindu (piem., katrs produkts atsevišķi).
	•	Pēc GROUP BY ir mazāk rindu (piem., katra kategorija viena rinda).

⸻

1) Svarīgi

Ja SELECT daļā ir kolonna, kas nav agregāta funkcijā, tad tai jābūt GROUP BY.

✅ Pareizi:

SELECT Country, COUNT(*) 
FROM Customers
GROUP BY Country;

❌ Nepareizi (CustomerName nav agregāts un nav GROUP BY):

SELECT Country, CustomerName, COUNT(*)
FROM Customers
GROUP BY Country;


⸻

2) Agregātu funkcijas (ko viņas dara)
	•	COUNT(*) — saskaita rindas grupā
	•	COUNT(column) — saskaita tikai tās rindas, kur column nav NULL
	•	SUM(column) — saskaita kopā skaitliskas vērtības
	•	AVG(column) — vidējā vērtība
	•	MIN(column) — mazākā vērtība
	•	MAX(column) — lielākā vērtība

⸻

3) GROUP BY ar 1 lauku (vienkāršākais)

Situācija: “Cik produktu ir katrā kategorijā?”

SELECT
  c.CategoryName,
  COUNT(*) AS ProductCount
FROM Products p
JOIN Categories c ON c.CategoryID = p.CategoryID
GROUP BY c.CategoryName
ORDER BY ProductCount DESC;

Ko nozīmē rezultāts?
Viena rinda = viena kategorija.

⸻

4) Vairāki agregāti vienā vaicājumā (nākamais līmenis)

Situācija: “Kategorijās parādīt produktu skaitu un cenu robežas.”

SELECT
  c.CategoryName,
  COUNT(*) AS ProductCount,
  MIN(p.Price) AS MinPrice,
  MAX(p.Price) AS MaxPrice
FROM Products p
JOIN Categories c ON c.CategoryID = p.CategoryID
GROUP BY c.CategoryName
ORDER BY ProductCount DESC;


⸻

5) GROUP BY ar 2 laukiem

Situācija: “Cik pasūtījumu ir katrā valstī ar katru piegādātāju?”

SELECT
  cu.Country,
  sh.ShipperName,
  COUNT(o.OrderID) AS OrdersCount
FROM Orders o
JOIN Customers cu ON cu.CustomerID = o.CustomerID
JOIN Shippers sh ON sh.ShipperID = o.ShipperID
GROUP BY cu.Country, sh.ShipperName
ORDER BY cu.Country ASC, OrdersCount DESC;

Ko nozīmē rezultāts?
Viena rinda = (valsts + piegādātājs) kombinācija.

⸻

6) WHERE vs HAVING (biežākā kļūda)
	•	WHERE filtrē rindas pirms grupēšanas (pirms GROUP BY).
	•	HAVING filtrē grupas pēc grupēšanas (pēc tam, kad aprēķināti SUM/COUNT/AVG…).

Piemērs: “Atstāt tikai piegādātājus ar vismaz 5 produktiem”

SELECT
  s.SupplierName,
  COUNT(p.ProductID) AS ProductCount
FROM Suppliers s
JOIN Products p ON p.SupplierID = s.SupplierID
GROUP BY s.SupplierName
HAVING COUNT(p.ProductID) >= 5
ORDER BY ProductCount DESC;


⸻

7) Tipiskie JOIN ceļi (špikeris uzdevumiem)
	•	Products → Categories (p.CategoryID = c.CategoryID)
	•	Products → Suppliers (p.SupplierID = s.SupplierID)
	•	Orders → Customers (o.CustomerID = cu.CustomerID)
	•	Orders → Shippers (o.ShipperID = sh.ShipperID)
	•	OrderDetails → Orders (od.OrderID = o.OrderID)
	•	OrderDetails → Products (od.ProductID = p.ProductID)

⸻

Uzdevumi (bez apakšvaicājumiem)

1) Kategoriju “cenu profils” (vairāki agregāti vienā vaicājumā)

Parādi katrai kategorijai:
	•	CategoryName
	•	produktu skaitu (COUNT)
	•	zemāko cenu (MIN Price)
	•	augstāko cenu (MAX Price)
Sakārto pēc produktu skaita dilstoši.

⸻

2) Produktu “pārdošanas profils” (SUM + AVG vienā vaicājumā)

Parādi katram produktam:
	•	ProductName
	•	kopējo pārdoto daudzumu (SUM OrderDetails.Quantity)
	•	vidējo pasūtīto daudzumu vienā rindā (AVG OrderDetails.Quantity)
Sakārto pēc kopējā pārdotā daudzuma dilstoši.

⸻

3) Piegādātāju statistika par produktu cenām (COUNT + AVG)

Parādi katram piegādātājam:
	•	SupplierName
	•	produktu skaitu (COUNT)
	•	vidējo produktu cenu (AVG Products.Price)
Sakārto pēc vidējās cenas dilstoši.

⸻

4) Divdimensiju grupēšana: pasūtījumi pa valsti un piegādātāju (2 GROUP BY lauki)

Parādi, cik pasūtījumu ir:
	•	Country (no Customers)
	•	ShipperName (no Shippers)
Agregāts: COUNT(Orders.OrderID)
Sakārto pēc valsts A–Z un pēc pasūtījumu skaita dilstoši.

⸻

5) Divdimensiju grupēšana: pārdotās vienības pa kategoriju un piegādātāju (2 GROUP BY lauki)

Parādi katrai kombinācijai:
	•	CategoryName
	•	SupplierName
Agregāts: SUM(OrderDetails.Quantity) kā pārdotās vienības
Sakārto pēc SUM(Quantity) dilstoši.

⸻

6) HAVING: atstāj tikai “aktīvās” grupas (filtrs pēc agregāta)

Izvēlies vienu no variantiem (vai abus, ja paspēj):
	•	A) Kategorijas, kur kopā pārdotas vismaz 200 vienības:
CategoryName + SUM(Quantity), ar HAVING SUM(Quantity) >= 200
	•	B) Piegādātāji, kuriem ir vismaz 5 produkti:
SupplierName + COUNT(Products), ar HAVING COUNT(*) >= 5

Sakārto rezultātu dilstoši pēc agregāta.
